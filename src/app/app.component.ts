import { Component, ViewChild, ElementRef } from '@angular/core';
import { FormControl } from '@angular/forms';
import { Observable } from  "rxjs/Rx";
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/debounceTime';
import 'rxjs/add/operator/distinctUntilChanged';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/toPromise';

import { MdDialog, MdDialogRef, MdSnackBar } from '@angular/material';

import { ISlimScrollOptions } from 'ng2-slimscroll';

import * as d3 from "d3";
import * as graphlibdot from "graphlib-dot"

import { ElasticsearchService } from './services'


/**
 * The root-component for the app
 */
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Malware Graph Analysis'
  initGraphId = '00cafd92ff4ead8b6a27a0824b0f3b35a5972bc79fb5d54a42e3114cc923b80d'
  query = new FormControl()
  total: number
  totalRight: number
  selected = true
  selectedRight = false
  results: {_index:string, _id: string, _type: string, _source: Object, highlight: Object}
  resultsRight: {_index:string, _id: string, _type: string, _source: Object, highlight: Object}
  graphSvg: any
  selectedNode: any
  graphModel: any
  rightGraphModel: any
  nodeStats: any
  @ViewChild('graphContainer') graphContainer: ElementRef
  @ViewChild('secondGraphContainer') secondGraphContainer: ElementRef
  @ViewChild('subgraphStats') subgraphStats: ElementRef
  opts: ISlimScrollOptions
  statsToggle = false
  displayMode = 1

  constructor(
    private elasticsearchService: ElasticsearchService,
    private elementRef: ElementRef
  ) { }

  
  ngOnInit() {
    this.opts = {
      position: 'right',
      barBackground: '#666'
    }
    this.query.valueChanges
      .debounceTime(400)
      .distinctUntilChanged()
      .do(query => {
        if (query.length == 0) {
          this.total = undefined;
        }
      })
      .filter(query => query.length > 0)
      .switchMap(query => this.elasticsearchService.search(query))
      .subscribe(res => {
        this.total = res['total'];
        this.results = res['hits'];
        this.selected = false;
        // this.results.map(res => res['except'])
      },
      error =>  console.log('incorrect search query'))
  }

  ngAfterViewInit() {
    this.elasticsearchService.fetch(
      this.initGraphId, 'svg')
      .toPromise()
      .then(res => {
        this.graphContainer.nativeElement.innerHTML = res
        this.enableInteractive(this.graphContainer)
        this.enableZoom(this.graphContainer)
      })

    this.elasticsearchService.fetch(
      this.initGraphId, 'dot')
      .toPromise()
      .then(res => {
        this.graphModel = graphlibdot.read(res)
      })

    this.elasticsearchService.mlt(this.initGraphId, 0.3659257618476297, 5)
      .toPromise()
      .then(res => {
        this.totalRight = res['total']-1;
        this.resultsRight = res['hits'].filter(res => res._id != this.initGraphId)
        this.selectedRight = false
      })
  }

  switchDisplay(mode) {
    this.displayMode = mode
  }

  selectGraph(graphId, lon, lat) {
    this.selected = true
    this.total = null
    this.elasticsearchService.fetch(graphId, 'svg')
      .toPromise()
      .then(res => {
        this.graphContainer.nativeElement.innerHTML = res
        this.enableInteractive(this.graphContainer)
        this.enableZoom(this.graphContainer)
      })
    this.elasticsearchService.fetch(graphId, 'dot')
      .toPromise()
      .then(res => {
        this.graphModel = graphlibdot.read(res)
      })
    this.elasticsearchService.mlt(graphId, lon, lat)
      .toPromise()
      .then(res => {
        this.totalRight = res['total']-1
        this.resultsRight = res['hits'].filter(res => res._id != graphId)
        this.selectedRight = false
      })
  }

  selectSimilarGraph(graphId, lon, lat) {
    this.selectedRight = true
    this.totalRight = null
    this.elasticsearchService.fetch(graphId, 'svg')
      .toPromise()
      .then(res => {
        this.secondGraphContainer.nativeElement.innerHTML = res
        this.enableInteractive(this.secondGraphContainer)
        this.enableZoom(this.secondGraphContainer)
      })
    this.elasticsearchService.fetch(graphId, 'dot')
      .toPromise()
      .then(res => {
        this.rightGraphModel = graphlibdot.read(res)
      })
  }

  enableZoom(selector) {
    // let viewDiv = d3.select(this.graphContainer.nativeElement);
    let svg = d3.select(selector.nativeElement).select('svg')

    // svg.select('g').attr('transform', 'scale(1 1) rotate(0)')

    // let divWidth = +viewDiv.style('width').slice(0, -2);
    // let divHeight = +viewDiv.style('height').slice(0, -2);
    // let svgViewBox = svg.attr('viewBox').split(' ');
    // let svgWidth = +svgViewBox[2];
    // let svgHeight = +svgViewBox[3];
    // let corFactor = Math.max(svgWidth/divWidth, svgHeight/divHeight);

    svg
      // .append("rect")
      // .attr("width", divWidth*corFactor)
      // .attr("height", divHeight*corFactor)
      // .attr("x", -(divWidth*corFactor-svgWidth)/2)
      // .attr("y", -(divHeight*corFactor-svgHeight)/2)
      // .attr("fill", "none")
      .attr("pointer-events", "all")
      .call(d3.zoom()
          .scaleExtent([1 / 2, 8])
          .on("zoom", () => svg.select('g').attr("transform", d3.event.transform)))
  }

  enableInteractive(selector) {
    var colorMap = {
      'entry0': '#ff3333',
      'sym': '#dde932',
      'fcn': '#4286f4',
      'sub': '#7cefa2',
      'section': '#f24892'
    }
    var that = this
    let svg = d3.select(selector.nativeElement).select('svg')
    svg.selectAll('g.node').style("cursor", "pointer")
    svg.selectAll('g.node')
      .each(function(d) {
        let node = d3.select(this)
        let nodeType = node.select('text').text().split('.')[0]
        node.select('ellipse').attr('fill', colorMap[nodeType])
      })
    svg.selectAll('g.node')
      .on('mouseover', function(d, i) {
        d3.select(this).select('ellipse').attr('fill', '#dd3216')
        if (that.displayMode == 1) {
          that.selectedNode = d3.select(this).select('title').text()
          that.calNodeStats(that.selectedNode)
          that.drawCallStats(that.selectedNode)
          that.statsToggle = true
        }
      })
    
    svg.selectAll('g.node')
      .on('mouseout', function(d, i) {
        let node = d3.select(this);
        let nodeType = node.select('text').text().split('.')[0]
        node.select('ellipse').attr('fill', colorMap[nodeType])
          // .style("cursor", "default");
        that.selectedNode = null
        
      })
    
    // svg.selectAll('g.node')
    //   .on('mouseup', function(d, i) {
    //     that.selectedNode = d3.select(this).select('title').text()
    //     console.log('click '+that.selectedNode)
    //     that.drawCallStats(that.selectedNode)
    //   })
  }

  private zip(rows) {
    return rows[0].map((_,c)=>rows.map(row=>row[c]))
  }


  calNodeStats(nodeId) {
    let node = this.graphModel.node(nodeId)
    this.nodeStats = {
      'id': nodeId,
      'label': node.label,
      'predecessors': this.graphModel.predecessors(nodeId),
      'successors': this.graphModel.successors(nodeId),
      'in': this.graphModel.inEdges(nodeId).length,
      'out': this.graphModel.outEdges(nodeId).length
    }
  }


  drawCallStats(nodeId) {
    d3.select("body").select("#subgraphStats").select('svg').remove()

    // get data from json file
    var d = JSON.parse(this.graphModel.node(nodeId).one_gram.split("'").join('"'))
    var dVal = Object.keys(d).map(k => d[k])
    if (dVal.length) {
      var sum: number = dVal.reduce((a,b) => a+b)
    } else {
      var sum: number = 1
    }
    var data = this.zip([Object.keys(d), Object.keys(d).map(k => d[k]/sum)])
                   .filter(d => d[1]>0.05)
    var size = 320
    
    // margins of the graph
    var margin = {top: 10, right: 10, bottom: 10, left: 10},
        width = size - margin.left - margin.right,
        height = size - margin.top - margin.bottom;

    // // set scales
    // var x = d3.scaleBand()
    //           .range([0, width])
    //           .padding(0.1);
    // var y = d3.scaleLinear()
    //           .range([height, 0]);
              
    // create svg
    
    var svg = d3.select("body").select("#subgraphStats")
      .append('svg')
      .attr('width', 320)
      .attr('height', 280)
      .append("g")
        .attr("transform", 
              "translate(" + 160 + "," + 120 + ")");
  
    // // bar chart
    // // Scale the range of the data in the domains
    // x.domain(data.map(function(d:any) { return d[0]; }));
    // y.domain([0, d3.max(data, function(d:any) { return d[1]; })]);

    // // append the rectangles for the bar chart
    // svg.selectAll(".bar")
    //   .data(data)
    // .enter().append("rect")
    //   .attr("class", "bar")
    //   .attr("x", function(d:any) { return x(d[0]); })
    //   .attr("width", x.bandwidth())
    //   .attr("y", function(d:any) { return y(d[1]); })
    //   .attr("height", function(d:any) { return height - y(d[1]); })
    //   .attr("fill", "steelblue");

    // // call the x Axis
    // svg.append("g")
    //   .attr("transform", "translate(0," + height + ")")
    //   .call(d3.axisBottom(x));

    // // call the y Axis
    // svg.append("g")
    //   .call(d3.axisLeft(y));

    // pie chart
    var radius = Math.min(width, height) / 2 - 45;

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var arc = d3.arc()
        .outerRadius(radius - 10)
        .innerRadius(0);

    var labelArc = d3.arc()
        .outerRadius(radius + 1)
        .innerRadius(radius + 8);

    var pie: any = d3.pie()
        .sort(null)
        .value(function(d) { return d[1]; });

    // var svg1 = d3.select("body").select("subgraphStats")
    //     .append('svg')
    //     .attr('width', 300)
    //     .attr('height', 300)
    //     .append("g")
    //     .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    var g = svg.selectAll(".arc")
      .data(pie(data))
      .enter().append("g")
      .attr("class", "arc");

    g.append("path")
      .attr("d", arc)
      .style("fill", function(d:any):any { return color(d.data[0]); });
    
    g.append("text")
      .attr("transform", function(d:any) { return "translate(" + 
        labelArc.centroid(d).map((d, i) => i==0 ? d-10 : d)
        + ")"; })
      .attr("dy", ".35em")
      .attr("font-size", 13)
      .text(function(d:any) { 
        return Math.round(d.data[1]*100)+'%'
      });
    var legend = svg.selectAll('.legend')
      .data(data)
      .enter()
      .append('g')
      .attr('class', 'legend')
      .attr('transform', function(d, i) {
        return 'translate(' + ((i*60) % 300-140)  + ',' + (130+Math.round((i*60-130)/300)*18) + ')'
      })
    legend.append('rect')
      .attr('width', 20)
      .attr('height', 10)
      .style('fill', function(d:any):any { return color(d[0]); })
    legend.append('text')
      .attr('x', 25)
      .attr('y', 7)
      .attr("font-size", 13)
      .text(function(d:any):any { return d[0]; });
  }

}
